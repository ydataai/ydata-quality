"""
Implementation of main class for Data Quality checks.
"""
from typing import List, Union, Optional

import pandas as pd

from ydata_quality.core.warnings import QualityWarning, Priority
from ydata_quality.duplicates import DuplicateChecker
from ydata_quality.labelling import LabelInspector
from ydata_quality.missings import MissingsProfiler
from ydata_quality.valued_missing_values import VMVIdentifier

class DataQuality:
    "DataQuality contains the multiple data quality engines."

    def __init__(self,
                    df: pd.DataFrame,
                    target: str = None,
                    entities: List[Union[str, List[str]]] = [],
                    vmv_extensions: Optional[list]=[]
                    ):
        """
        Engines:
        - Duplicates
        - Missing Values
        - Labelling
        - Valued Missing Values

        Args:
            df (pd.DataFrame): reference DataFrame used to run the DataQuality analysis.
            target (str, optional): [MISSINGS, LABELLING] target feature, to be predicted.
                                    If not specified, LABELLING is skipped.
            entities: [DUPLICATES] entities relevant for duplicate analysis.
            vmv_extensions: [VALUED MISSING VALUES] A list of user provided valued missing values to append to defaults.
        """
        self.df = df
        self._target = target
        self._engines = {
            'duplicates': DuplicateChecker(df=df, entities=entities),
            'missings': MissingsProfiler(df=df, target=target),
            'labelling': LabelInspector(df=df, label=target),
            'valued-missing-values': VMVIdentifier(df=df, vmv_extensions=vmv_extensions)
        }
        self._warnings = set()

    @property
    def warnings(self):
        "Set of warnings generated by individual QualityEngines."
        return self._warnings

    def get_warnings(self,
                    category: Optional[str] = None,
                    test: Optional[str] = None,
                    priority: Optional[Priority] = None) -> List[QualityWarning]:
        "Retrieves warnings filtered by their properties."
        filtered = list(self.warnings) # convert original set
        filtered = [w for w in filtered if w.category == category] if category else filtered
        filtered = [w for w in filtered if w.test == test] if test else filtered
        filtered = [w for w in filtered if w.priority == Priority(priority)] if priority else filtered
        filtered.sort() # sort by priority
        return filtered

    @property
    def engines(self):
        "Dictionary of instantiated engines to run data quality analysis."
        return self._engines

    def __store_warnings(self):
        "Appends all warnings from individiual engines into warnings of DataQuality main class."
        for engine in self.engines.values():
            self._warnings = self._warnings.union(set(engine.get_warnings()))

    def __trim_engines(self):
        "Heuristics to activate/deactivate individual engines from running."
        if self._target is None: # doesn't run labelling engine if target is not specified
            self._engines.pop('labelling')

    def evaluate(self):
        "Runs all the individual data quality checks and aggregates the results."
        self.__trim_engines()
        results = {name: engine.evaluate() for name, engine in self.engines.items()}
        self.__store_warnings()
        return results

    def report(self):
        "Prints a report containing all the warnings detected during the data quality analysis."
        # TODO: Provide a count of warnings by priority
        self.__store_warnings() # fetch all warnings from the engines
        self._warnings = set(sorted(self.warnings)) # Sort the warnings by priority
        for warn in self.warnings:
            print(warn)

